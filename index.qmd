---
editor: 
  markdown: 
    wrap: 72
---

## Introduction

This workshop is designed to provide beginners with foundational understanding of R programming language. Through a combination of theoretical explanations, hands-on coding exercises, and practical applications, participants will learn how to leverage R for data visualization of cancer biology datasets.

The workshop will cover essential programming concepts and gradually introduce more advanced topics, with a focus on using the ggplot2 package suite for data visualization. The aim of this workshop is to analyse data and create informative plots.

## Learning Objectives

Participants will gain the following skills:

-   Proficiency in using R and RStudio for data analysis.
-   Basic R programming skills.
-   Reading datasets using `readr` package.
-   Creating various types of plots using `ggplot2` package.

## Prerequisites

Before starting this course you will need to ensure that your computer
is set up with the required software. If you have any difficulty
installing any of this software then please contact one of the trainers
for help.

### Installing R and RStudio

**R** and **RStudio** are separate downloads and installations.

**R** is the underlying statistical computing environment. The base R
system and a very large collection of packages that give you access to a
huge range of statistical and analytical functionality are available
from [CRAN](https://cran.r-project.org), the Comprehensive R Archive
Network.

However, using R alone is no fun. **RStudio** is a graphical integrated
development environment (IDE) that makes using R much easier and more
interactive.

#### Local Installation

You need to install R before you install RStudio.

```{=html}
<details>
<summary style="font-weight: 600;" >
Windows
</summary>
```
-   **If you already have R and RStudio installed:**

    -   Open RStudio, and click on "Help" \> "Check for updates". If a
        new version is available, quit RStudio, and download the latest
        version for RStudio.
    -   To check which version of R you are using, start RStudio and the
        first thing that appears in the console indicates the version of
        R you are running. Alternatively, you can type `sessionInfo()`,
        which will also display which version of R you are running. Go
        on the [CRAN
        website](https://cran.r-project.org/bin/windows/base/) and check
        whether a more recent version is available. If so, please
        download and install it. You can [check
        here](https://cran.r-project.org/bin/windows/base/rw-FAQ.html#How-do-I-UNinstall-R_003f)
        for more information on how to remove old versions from your
        system if you wish to do so.

-   **If you don't have R and RStudio installed:**

    -   Download R from the [CRAN
        website](https://cran.r-project.org/bin/windows/base/release.htm).
    -   Run the `.exe` file that was just downloaded
    -   Go to the [RStudio download
        page](https://www.rstudio.com/products/rstudio/download/#download)
    -   Under *Installers* select **RStudio x.yy.zzz - Windows 10/8/7**
        where x, y, and z represent version numbers)
    -   Double click the file to install it
    -   Once it's installed, open RStudio to make sure it works and you
        don't get any error messages.

</details>

```{=html}
<details>
<summary style="font-weight: 600;" >macOS</summary>
```
-   **If you already have R and RStudio installed:**

    -   Open RStudio, and click on "Help" \> "Check for updates". If a
        new version is available, quit RStudio, and download the latest
        version for RStudio.
    -   To check the version of R you are using, start RStudio and the
        first thing that appears on the terminal indicates the version
        of R you are running. Alternatively, you can type
        `sessionInfo()`, which will also display which version of R you
        are running. Go on the [CRAN
        website](https://cran.r-project.org/bin/macosx/) and check
        whether a more recent version is available. If so, please
        download and install it.

-   **If you don't have R and RStudio installed:**

    -   Download R from the [CRAN
        website](https://cran.r-project.org/bin/macosx/).
    -   Select the `.pkg` file for the latest R version
    -   Double click on the downloaded file to install R
    -   It is also a good idea to install
        [XQuartz](https://www.xquartz.org/) (needed by some packages)
    -   Go to the [RStudio download
        page](https://www.rstudio.com/products/rstudio/download/#download)
    -   Under *Installers* select **RStudio x.yy.zzz - Mac OS X 10.6+
        (64-bit)** (where x, y, and z represent version numbers)
    -   Double click the file to install RStudio
    -   Once it's installed, open RStudio to make sure it works and you
        don't get any error messages.

</details>

```{=html}
<details>
<summary style="font-weight: 600;" >
Linux
</summary>
```
-   Follow the instructions for your distribution from
    [CRAN](https://cloud.r-project.org/bin/linux), they provide
    information to get the most recent version of R for common
    distributions. For most distributions, you could use your package
    manager (e.g., for Debian/Ubuntu run `sudo apt-get install r-base`,
    and for Fedora `sudo yum install R`), but we don't recommend this
    approach as the versions provided by this are usually out of date.
    In any case, make sure you have at least R 4.3.2.
-   Go to the [RStudio download
    page](https://www.rstudio.com/products/rstudio/download/#download)
-   Under *Installers* select the version that matches your
    distribution, and install it with your preferred method (e.g., with
    Debian/Ubuntu `sudo dpkg -i   rstudio-x.yy.zzz-amd64.deb` at the
    terminal).
-   Once it's installed, open RStudio to make sure it works and you
    don't get any error messages.

</details>

### Installing R Packages

On this course we will be making use of a brilliant collection of
packages designed for data science called the **`tidyverse`** that make
it much easier and more fun to work with your data. After installing R
and RStudio, follow the instructions below to install the `tidyverse`
package suite.

-   After starting RStudio, at the console type:
    `install.packages("tidyverse")` (look for the 'Console' tab and type
    at the `>` prompt)
-   You can also do this by going to Tools -\> Install Packages and
    typing the names of the packages separated by a comma.

## Data

The Metabric study characterized the genomic mutations and gene
expression profiles for 2509 primary breast tumours. In addition to the
gene expression data generated using microarrays, genome-wide copy
number profiles were obtained using SNP microarrays. Targeted sequencing
was performed for 2509 primary breast tumours, along with 548 matched
normals, using a panel of 173 of the most frequently mutated breast
cancer genes as part of the Metabric study.

**Refrences:**

-   [Curtis *et al.*, Nature 486:346-52,
    2012](https://pubmed.ncbi.nlm.nih.gov/22522925)
-   [Pereira *et al.*, Nature Communications 7:11479,
    2016](https://www.ncbi.nlm.nih.gov/pubmed/27161491)

Both the clinical data and the gene expression values were downloaded
from
[cBioPortal](https://www.cbioportal.org/study/summary?id=brca_metabric).

We excluded observations for patient tumor samples lacking expression
data, resulting in a data set with fewer rows.

## R!

R is a powerful programming language and open-source software widely used for statistical computing and data analysis. This programming language is developed by Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand. R has gained popularity among statisticians, data scientists, researchers, and analysts for its flexibility, extensibility, and robust statistical capabilities.

## Why learn R?

Here are several compelling reasons to consider learning R:

-   Statistical Analysis
-   Data Visualization
-   Open Source
-   Community Support
-   Extensibility
-   Integration with Other Languages
-   Data Science and Machine Learning
-   Widely Used in Academia and Industry
-   Continuous Development

## Getting Started with R

To begin working with R, users typically install an Integrated Development Environment (IDE) such as RStudio, which provides a user-friendly interface for coding, debugging, and visualizing results. R scripts are written in the R language and can be executed interactively or saved for later use.

## A look around RStudio

Open RStudio. You will see four windows (aka *panes*). Each window has a different function. The screenshot below shows an [analogy linking the different RStudio windows to cooking](https://twitter.com/RLadiesNCL/status/1138812826917724160).

![](images/rstudiopanes.jpeg){fig-align="center"}

### Console Pane

![](images/console-pane.png){fig-align="center"}

On the left-hand side, you'll find the *console*. This is where you can input commands (code that R can interpret), and the responses to your commands, known as *output*, are displayed here. While the console is handy for experimenting with code, it doesn't save any of your entered commands. Therefore, relying exclusively on the console is not recommended.

### History Pane

![](images/history-pane.png){fig-align="center"}

The *history pane* (located in the top right window) maintains a record of the commands that you have executed in the R console during your current R session. This includes both correct and incorrect commands.

You can navigate through your command history using the up and down arrow keys in the *console*. This allows you to quickly recall and re-run previous commands without retyping them.

### Environment Pane

![](images/environment-pane.png){fig-align="center"}

The *environment pane* (located in the top right window) provides an overview of the objects (variables, data frames, etc.) that currently exist in your R session. It displays the names, types, dimensions, and some content of these objects. This allows you to monitor the state of your workspace in real-time.

### Plotting Pane

![](images/plotting-pane.png){fig-align="center"}

The *plotting pane* (located in the bottom right window) is where graphical output, such as plots and charts, is displayed when you create visualizations in R. The Plotting pane often includes tools for zooming, panning, and exporting plots, providing additional functionality for exploring and customizing your visualizations. 

### Help Pane

![](images/help-pane.png){fig-align="center"}

The *help pane* (located in the bottom right window) is a valuable resource for accessing documentation and information about R functions, packages, and commands. When you type a function or command in the console and press the <kbd>F1</kbd> key (Mac: <kbd>fn</kbd> + <kbd>F1</kbd>) the Help pane displays relevant documentation. Additionally, you can type a keyword in the text box at the top right corner of the Help Pane.

### Files Pane

![](images/files-pane.png){fig-align="center"}

The *files pane* provides a file browser and file management interface within RStudio. It allows you to navigate through your project directories, view files, and manage your file system.

### Packages Pane

![](images/package-pane.png){fig-align="center"}

This pane provides a user-friendly interface for managing R packages. It lists installed packages and allows you to load, unload, update, and install packages.

### Viewer Pane

![](images/viewer-pane.png){fig-align="center"}

It is used to display dynamic content generated by R, such as HTML, Shiny applications, or interactive visualizations.

## Working directory

Opening an RStudio session launches it from a specific location. This is the *working directory*. R looks in the working directory by default to read in data and save files. You can find out what the working directory is by using the command `getwd()`. This shows you the path to your working directory in the console. In Mac this is in the format `/path/to/working/directory` and in Windows `C:\path\to\working\directory`. It is often useful to have your data and R scripts in the same directory and set this as your working directory. We will do this now.

Make a folder for this course somewhere on your computer that you will be able to easily find. Name the folder for example, `Intro_R_course`. Then, to set this folder as your working directory:

In RStudio click on the Files tab and then click on the three dots, as shown below.

![](images/saveworkingdir1.png){fig-align="center"}

In the window that appears, find the folder you created (e.g. `Intro_R_course`), click on it, then click Open. The files tab will now show the contents of your new folder. Click on More → Set As Working Directory, as shown below.

![](images/setworkingdir.png){fig-align="center"}

Note: You can use an RStudio project as described here to automatically keep track of and set the working directory.

## Quarto Document

In RStudio, the Script pane (located at the top left window) serves as a dedicated space for writing, editing, and executing Quarto documents. It is where you compose and organize your R code, making it an essential area for creating reproducible and well-documented analyses.

RStudio provides syntax highlighting in the Script pane, making it easier to identify different components of your code. You can execute individual lines or selections of code from the Script pane. This helps in testing and debugging code without running the entire document.

### Open a New Quarto Document

Navigate to **File → New File → Quarto Document**. 

![](images/open-quarto.png)

Add a title (e.g. `IntroR`), your name as Author and save this document as 'IntroR-doc.qmd' in your current working directory (e.g. `IntroR`). A new pane will emerge in the top-left corner.

![](images/naming-quarto.png)

Download the Quarto document from the following ![this link](https://github.com/Sanduni-P/IntroR-Viz/blob/main/utils/Notebook.qmd). Click the download raw file button at the right side. Open it using the RStudio. We will use it as a notebook during this workshop. 

![](images/download-notebook.png)

## Comments

In R, any text following the hash symbol \# is termed a *comment*. R disregards this text, considering it non-executable. Comments serve the purpose of documenting your code, aiding your future understanding of specific lines, and highlighting the intentions or challenges encountered.

RStudio makes it easy to comment or uncomment a paragraph: Select the lines you want to comment (to comment a set of lines) or placing the cursor at any location of a line (to comment a single line), press at the same time on your keyboard <kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd> (mac) or <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd> (Windows/Linux).

Extensive use of comments is encouraged throughout this course.

```{r}
# This is a comment. Ignored by R. But useful for me!
```

## Executing Commands

Executing commands or *running code* is the process of submitting a command to your computer, which does some computation and returns an answer. In RStudio, there are several ways to execute commands:

-   Select the line(s) of code using the mouse, and then click **Run** at the top right corner of the R text file.
-   Select **Run Lines** from the Code menu.
-   Click anywhere on the line of code and click **Run**.
-   Select the line(s) you want to run. Press <kbd>⌘</kbd> + <kbd>Return</kbd> (Mac) or <kbd>Ctrl</kbd> + <kbd>Enter</kbd> (Windows/Linux) to run the selected code.

We suggest the third option, which is fastest. This link provides a list of useful [RStudio keyboard shortcuts](https://support.posit.co/hc/en-us/articles/200711853-Keyboard-Shortcuts-in-the-RStudio-IDE) that can be beneficial when coding and navigating the RStudio IDE.

When you type in, and then run the commands shown in the grey boxes below, you should see the result in the Console pane at bottom left.

### Simple Maths in R

We can use R as a calculator to do simple maths.

```{r}
3 + 5
```

More complex calculator functions are *built in* to R, which is the reason it is popular among mathematicians and statisticians. 

**Task 1: What is the output of this expression: 6050 * 72 + 124 / 25000 * 0.001 - 433576**

## Getting Help

In R, the `?` operator is used for accessing help documentation for a specific function or topic. When you type `?` followed by the name of a function, you get detailed information about that function. For example try:

```{r}
?mean
```

```{=html}
<details>
<summary>View Output</summary>
```

```{r, echo = F}
#| classes: helpscroll
#| results: asis
#| echo: false
tools:::Rd2HTML(utils:::.getHelpFile(help(mean)))
```

```{=html}
</details>
```

The above command displays the help documentation for the `mean` function, providing information about its usage, arguments, and examples.

::: callout-tip
Tab completion A very useful feature is Tab completion. You can start typing and use <kbd>Tab</kbd> to autocomplete code, for example, a function name.
:::

## R Packages

Many developers have built 1000s of functions and shared them with the R user community to help make everyone's work easier and more efficient. These functions (short programs) are generally packaged up together in (wait for it) *Packages*. For example, the tidyverse package is a compilation of many different functions, all of which help with data transformation and visualization. Packages also contain data, which is often included to assist new users with learning the available functions.

### Installing Packages

Packages are hosted on repositories, with [CRAN (Comprehensive R Archive Network)](https://cran.r-project.org/web/packages/available_packages_by_date.html) being the primary repository. To install packages from CRAN, you use the `install.packages()` function. For example:

```{r}
#| eval: false
install.packages("tidyverse")
```

This will spit out a lot of text into the console as the package is being installed. Once complete you should have a message:

`The downloaded binary packages are in...` followed by a long directory name.

To remove an installed package:

```{r}
#| eval: false
remove.packages("tidyverse")
```

### Loading Packages

After installation, you need to load a package into your R session using the `library()` function. For example:

```{r}
library(tidyverse)
```

This makes the functions and datasets from the 'tidyverse' package available for use in your current session.

::: callout-tip
You only need to install a package once. Once installed, you don't need to reinstall it in subsequent sessions. However, you do need to load the package at the beginning of each R session using the `library()` function before you can utilize its functions and features. This ensures that the package is actively available for use in your current session.
:::

**Task 2: Install and load the two packeages: `readr` and `ggplot2`.**

### Package Documentation

Each package comes with documentation that explains how to use its functions. You can access this information using the `help()` function or by using `?` before the function name:

```{r}
help(tidyverse)
```

```{=html}
<details>
<summary>View Output</summary>
```

```{r, echo = F}
#| classes: helpscroll
#| results: asis
#| echo: false
tools:::Rd2HTML(utils:::.getHelpFile(help(tidyverse)))
```

```{=html}
</details>
```

**Task 3: Display the documentation of readr package.**

## Visualizing Data

`ggplot2` package simplifies the creation of plots using data frames. This package offers a streamlined interface for defining variables to plot, configuring their display, and adjusting visual attributes. Consequently, adapting to changes in the data or transitioning between plot types requires only minimal modifications. This feature facilitates the creation of high-quality plots suitable for publication with minimal manual adjustments.

### Reading the Data

In this section, you'll learn the basics of reading data files into R using the **readr** package. We will use the `read_csv()` function from readr package to import a dataset. CSV short for Comma Separated Values, is a text format commonly used to store tabular data. Conventionally the first line contains column headings.

The first argument of the `read_csv()` function takes the path to the file (or a web link). The following code will download the metabric dataset.

```{r}
#| warning: false
library(readr)
metabric <- read_csv("https://zenodo.org/record/6450144/files/metabric_clinical_and_expression_data.csv")
```

### Exploring the Data

In the previous section we imported a dataset, into a dataframe named *metabric*. This section demonstrates different ways to view this dataset.

When the name of the object (data frame) is typed, the first few lines along with some information, such as the number of rows are displayed:

```{r}
#| eval: false
#| classes: scrolling
metabric
```

```{=html}
<details>
<summary>Output</summary>
```

```{r}
#| echo: false
#| classes: scrolling
head(metabric, n = 10)
```

```{=html}
</details>
```

The `dim()` function prints the dimensions (rows x columns) of the data frame:

```{r}
#| eval: false
dim(metabric)
```

```{=html}
<details>
<summary>Output</summary>
```

```{r}
#| echo: false
dim(metabric)
```

```{=html}
</details>
```

This information is available at the environment pane in the top right panel as the number of observations (rows) and variables (columns).

The `nrow()` function prints the number of rows while `ncol()` prints the number of columns:

```{r}
#| eval: false
nrow(metabric)
ncol(metabric)
```

```{=html}
<details>
<summary>Output</summary>
```

```{r}
#| echo: false
nrow(metabric)
ncol(metabric)
```

```{=html}
</details>
```

The `View()` function gives a spreadsheet-like view of the data frame:

```{r}
#| eval: false
View(metabric)
```

By clicking the object on the environment tab also gives a spreadsheet-like view of the object: ![](images/environment-variable.jpg){fig-align="center"}

The `head()` function prints the top 6 rows of a data frame:

```{r}
#| eval: false
#| classes: scrolling
head(metabric)
```

```{=html}
<details>
<summary>Output</summary>
```

```{r}
#| echo: false
#| classes: scrolling
head(metabric)
```

```{=html}
</details>
```

Similarly, the `tail()` function prints the bottom 6 rows of the data frame:

```{r}
#| eval: false
tail(metabric)
```

```{=html}
<details>
<summary>Output</summary>
```

```{r}
#| echo: false
#| classes: scrolling
tail(metabric)
```

```{=html}
</details>
```

The `colnames()` function displays all the column names:

```{r}
#| classes: scrolling
colnames(metabric)
```

## Building a Basic Plot

The construction of ggplot graphics is incremental, allowing for the addition of new elements in layers. This approach grants users extensive flexibility and customization options, enabling the creation of tailored plots to suit specific needs.

![](http://ohi-science.org/data-science-training/img/rstudio-cheatsheet-ggplot.png)

To build a ggplot, the following basic template can be used for different types of plots. 

![](images/ggplot.png) Three things are required for a ggplot:

### 1. The data

We first specify the data frame that contains the relevant data to create a plot. Here we are sending the metabric dataset to the `ggplot()` function.

```{r}
#| fig-height: 4
#| fig-align: center
# render plot background
ggplot(data = metabric)
```

This command results in an empty gray panel. We must specify how various columns of the data frame should be depicted in the plot.

### 2. Aesthetics `aes()`

Next, we specify the columns in the data we want to map to visual properties (called aesthetics or `aes` in ggplot2). e.g. the columns for x values, y values and colours.

Since we are interested in generating a scatter plot, each point will have an x and a y coordinate. Therefore, we need to specify the x-axis to represent the transcription factor (GATA3) and y-axis to represent the estrogen receptor alpha (ESR1). 

```{r}
#| fig-height: 4
#| fig-align: center
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1))
```

This results in a plot which includes the grid lines, the variables and the scales for x and y axes. However, the plot is empty or lacks data points.

### 3. Geometric Representation `geom_()`

Finally, we specify the type of plot (the *geom*). There are different types of geoms:

```{=html}
<table class="unstyledTable">
<tbody>
<tr>
<td>
```
- ![](images/geom_blank.png){height="63"}
```{=html}
</td>
<td>
```
`geom_blank()` draws an **empty plot**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_segment.png){height="58"}
```{=html}
</td>
<td>
```
`geom_segment()` draws a **straight line**. `geom_vline()` draws a **vertical line** and `geom_hline()` draws a **horizontal line**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_curve.png){height="58"}
```{=html}
</td>
<td>
```
`geom_curve()` draws a **curved line**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_path.png){height="58"}
```{=html}
</td>
<td>
```
`geom_line()/geom_path()` makes a **line plot**. `geom_line()` connects points from left to right and `geom_path()` connects points in the order they appear in the data.
```{=html}
</td>
</tr>
<tr>
<td colspan=2><hr></td>
</tr>
<tr>
<td>
```
- ![](images/geom_point.png){height="58"}
```{=html}
</td>
<td>
```
`geom_point()` produces a **scatterplot**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_jitter.png){height="58"}
```{=html}
</td>
<td>
```
`geom_jitter()` adds a small amount of **random noise** to the points in a scatter plot.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_dotplot.png){height="58"}
```{=html}
</td>
<td>
```
`geom_dotplot()` produces a **dot plot**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_smooth.png){height="58"}
```{=html}
</td>
<td>
```
`geom_smooth()` adds a **smooth trend line to a plot**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_quantile.png){height="58"}
```{=html}
</td>
<td>
```
`geom_quantile()` draws **fitted quantile with lines** (a scatter plot with regressed quantiles).
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_density.png){height="58"}
```{=html}
</td>
<td>
```
`geom_density()` creates a **density plot**.
```{=html}
</td>
</tr>
<tr>
<td colspan=2><hr></td>
</tr>
<tr>
<td>
```
- ![](images/geom_histogram.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_histogram()` produces a **histogram**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_bar.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_bar()` makes a **bar chart**. Height of the bar is proportional to the number of cases in each group.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_col.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_col()` makes a **bar chart**. Height of the bar is proportional to the values in data.
```{=html}
</td>
</tr>
<tr>
<td colspan=2><hr></td>
</tr>
<tr>
<td>
```
- ![](images/geom_boxplot.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_boxplot()` produces a **box plot**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_violin.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_violin()` creates a **violin plot**.
```{=html}
</td>
</tr>
<tr>
<td colspan=2><hr></td>
</tr>
<tr>
<td>
```
- ![](images/geom_ribbon.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_ribbon()` produces a **ribbon** (y interval defined line).
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_area.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_area()` draws an **area plot**, which is a line plot filled to the y-axis (filled lines).
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_rect.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_rect()`, `geom_tile()` and `geom_raster()` draw **rectangles**.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_polygon.png){height="58"} 
```{=html}
</td>
<td>
```
`geom_polygon()` draws **polygons**, which are filled paths.
```{=html}
</td>
</tr>
<tr>
<td colspan=2><hr></td>
</tr>
<tr>
<td>
```
- ![](images/geom_text.png){height="58"}
```{=html}
</td>
<td>
```
`geom_text()` adds **text** to a plot.
```{=html}
</td>
</tr>
<tr>
<td>
```
- ![](images/geom_label.png){height="58"}
```{=html}
</td>
<td>
```
`geom_text()` adds **label** to a plot.
```{=html}
</td>
</tr>
</tbody>
</table>
```

The range of geoms available in `ggplot2` can be obtained by navigating to the
`ggplot2` package in the Packages tab pane in RStudio (bottom right-hand corner)
and scrolling down the list of functions sorted alphabetically to the `geom_...`
functions.

Since we are interested in creating a scatter plot, the geometric representation of the data will be in point form. Therefore we use the `geom_point()` function.

To plot the expression of estrogen receptor alpha (ESR1) against that of the transcription factor, GATA3:

```{r}
#| fig-height: 4
#| fig-align: center
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) + geom_point() 
```

Notice that we use the `+` sign to add a *layer* of points to the plot. This concept bears resemblance to Adobe Photoshop, where layers of images can be rearranged and edited independently. In ggplot, each layer is added over the plot in accordance with its position in the code using the `+` sign.

## Customizing Plots

### Adding Colour

The above plot could be made more informative. For instance, the additional information regarding the ER status (i.e., ER_status column) could be incorporated into the plot. To do this, we can utilize `aes()` and specify which column in the `metabric` data frame should be represented as the color of the points.

```{r}
#| fig-height: 4
#| fig-align: center
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour)) +
    geom_point(mapping = aes(colour = ER_status)) 
```

Notice that we specify the `colour = ER_status` argument in the `aes()` mapping inside the `geom_()` function instead of `ggplot()` function.

To colour points based on a continuous variable, for example: Nottingham prognostic index (NPI):

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(aes(colour = Neoplasm_histologic_grade)) 
```

In `ggplot2`, a color scale is used for continuous variables, while discrete or categorical values are represented using discrete colors.

Note that some patient samples lack expression values, leading `ggplot2` to remove those points with missing values for ESR1 and GATA3.

### Adding Shape

Let's add shape to points. 

```{r}
#| fig-height: 4
#| fig-align: center
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) + 
  geom_point(mapping = aes(shape = `3-gene_classifier`))
```
Note that some patient samples have not been classified and ggplot has removed those points with missing values for the three-gene classifier.

The shape argument allows you to customize the appearance of all data points by assigning an integer associated with predefined shapes shown below:

![](images/shapes.png){fig-align="center" height="120"}

To use asterix instead of points in the plot: 

```{r}
#| fig-height: 4
#| fig-align: center
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) + 
  geom_point(shape = 8)
```

It would be useful to be able to change the shape of all the points. We can do so by setting the size to a single value rather than mapping it to one of the variables in the data set - this has to be done outside the aesthetic mappings (i.e. outside the `aes()` bit) as above. 

::: callout-tip
#### Aesthetic Setting vs. Mapping

Instead of mapping an aesthetic property to a variable, you can set it to a single value by specifying it in the layer parameters (outside `aes()`). We map an aesthetic to a variable (e.g., `aes(shape = `3-gene_classifier`)`) or set it to a constant (e.g., `shape = 8`). If you want appearance to be governed by a variable in your data frame, put the specification inside `aes()`; if you want to override the default size or colour, put the value outside of `aes()`.

```{r}
#| fig-height: 4
#| fig-align: center
#| layout-ncol: 2
# size outside aes()
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(shape = 8)

# size inside aes()
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(aes(shape = `3-gene_classifier`))
```

The above plots are created with similar code, but have rather different outputs. The first plot **sets** the size to a value and the second plot **maps** (not sets) the size to the three-gene classifier variable. 
:::

It is usually preferable to use colours to distinguish between different
categories but sometimes colour and shape are used together when we want to
show which group a data point belongs to in two different categorical variables.

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(aes(colour = PAM50, shape = `3-gene_classifier`))
```

### Adding Size and Transparency

We can adjust the size and/or transparency of the points.

Let's first increase the size of points.

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(mapping = aes(colour = PAM50), size = 2)
```

Note that here we add the size argument outside of the the aesthetic mapping. 

Transparency can be useful when we have a large number of points as we can more easily tell when points are overlaid, but like size, it is not usually mapped to a variable and sits outside the `aes()`.

Let's change the transparency of points. 

```{r}
#| fig-height: 4
#| fig-align: center
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(mapping = aes(colour = `3-gene_classifier`), alpha = 0.5) 
```

### Adding Layers {#sec-adding-layers}

We can add another *layer* to this plot using a different geometric representation (or `geom_` function) we discussed previously. 

Let's add trend lines to this plot using the `geom_smooth()` function which provide a summary of the data.

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point() +
  geom_smooth()
```

Note that the shaded area surrounding blue line represents the standard error bounds on the fitted model.

Let’s make the plot look a bit prettier by reducing the size of the points and making them transparent. We’re not mapping size or alpha to any variables, just setting them to constant values, and we only want these settings to apply to the points, so we set them inside `geom_point()`.

```{r}
#| fig-height: 4
#| fig-align: center
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth() 
```

Let's add some colour to the plot. 

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1, colour = ER_status)) +
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth()
```

### Adding Labels

By default, `ggplot` use the column names specified inside the `aes()` as the axis labels. We can change this using the `x = ` and `y =` arguments in `labs()` function.

```{r}
#| fig-align: center
#| warning: false
#| fig-height: 4
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(mapping = aes(colour = ER_status), size = 0.5, alpha = 0.5) +
  geom_smooth() +
  labs(x = "GATA3 Expression",
       y = "ESR1 Expression")
```

You can also add a title, a subtitle, a caption or a tag. 

```{r}
#| fig-align: center
#| warning: false
#| fig-height: 4
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(mapping = aes(colour = ER_status), size = 0.5, alpha = 0.5) +
  geom_smooth() +
  labs(
    title = "Expression of estrogen receptor alpha against the transcription factor",
    subtitle = "ESR1 vs GATA3",
    caption = "This is a caption",
    tag = "Figure 1",
    x = "GATA3 Expression",
    y = "ESR1 Expression")
```

### Themes

Themes control the overall appearance of the plot, including background color, grid lines, axis labels, and text styles. ggplot offers several built-in themes, and you can also create custom themes to match your preferences or the requirements of your publication. The default theme has a grey background.

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric, mapping = aes(x = GATA3, y = ESR1)) +
  geom_point(mapping = aes(colour = ER_status), size = 0.5, alpha = 0.5) +
  geom_smooth() + theme_bw()
```

Try these themes yourselves: `theme_classic()`, `theme_dark()`, `theme_grey()` (default), `theme_light()`, `theme_linedraw()`, `theme_minimal()`, `theme_void()` and `theme_test()`. 

## Different Types of Plots

### Bar chart

The metabric study redefined how we think about breast cancer by identifying and
characterizing several new subtypes, referred to as *integrative clusters*.
Let's create a bar chart of the number of patients whose cancers fall within
each subtype in the metabric cohort.

The `geom_bar` is the geom used to plot bar charts. It requires a single aesthetic mapping of the
categorical variable of interest to `x`.

```{r bar_plot_1}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric) +
  geom_bar(aes(x = Integrative_cluster))
```

The dark grey bars are a big ugly - what if we want each bar to be a different
colour?

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric) +
  geom_bar(aes(x = Integrative_cluster, colour = Integrative_cluster))
```

Colouring the edges wasn't quite what we had in mind. Look at the help for
`geom_bar` to see what other aesthetic we should have used.

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric) +
  geom_bar(aes(x = Integrative_cluster, fill = Integrative_cluster))
```


### Box plot

Box plots (or *box & whisker plots*) are a particular favourite seen in many seminars and papers. Box plots summarize the distribution of a set of values by displaying the minimum and maximum values, the median (i.e. middle-ranked value), and the range of the middle 50% of values (inter-quartile range). The whisker line extending above and below the IQR box define Q3 + (1.5 x IQR), and Q1 - (1.5 x IQR) respectively. 

![](https://miro.medium.com/max/18000/1*2c21SkzJMf3frPXPAR_gZA.png)
To create a box plot from Metabric dataset:

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric, mapping = aes(x = ER_status, y = GATA3)) +
  geom_boxplot()
```

Let's try a colour aesthetic to also look at how estrogen receptor expression
differs between HER2 positive and negative tumours.

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric, mapping = aes(x = ER_status, y = GATA3, colour = HER2_status)) +
  geom_boxplot() 
```

### Violin plot

A *violin plot* is used to visualize the distribution of a numeric variable across different categories. It combines aspects of a box plot and a kernel density plot. 

The width of the violin at any given point represents the density of data at that point. Wider sections indicate a higher density of data points, while narrower sections indicate lower density. By default, violin plots are symmetric.

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric, aes(y = GATA3, x = ER_status, colour = HER2_status)) + 
  geom_violin()
```

### Histogram

The geom for creating histograms is, rather unsurprisingly, `geom_histogram()`.

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric) +
  geom_histogram(aes(x = Age_at_diagnosis))
```

The warning message hints at picking a more optimal number of bins by specifying
the `binwidth` argument.

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric) +
  geom_histogram(aes(x = Age_at_diagnosis), binwidth = 5)
```

Or we can set the number of bins.

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric) +
  geom_histogram(aes(x = Age_at_diagnosis), bins = 20)
```

These histograms are not very pleasing, aesthetically speaking - how about some
better aesthetics?

```{r}
#| fig-align: center
#| fig-height: 4
ggplot(data = metabric) +
  geom_histogram(
    aes(x = Age_at_diagnosis), 
    bins = 20, 
    colour = "darkblue", 
    fill = "grey")
```

## Saving plot images

Use `ggsave()` to save the last plot you displayed.

```{r eval = FALSE}
ggsave("age_at_diagnosis_histogram.png")
```

You can alter the width and height of the plot and can change the image file type.

```{r eval = FALSE}
ggsave("age_at_diagnosis_histogram.pdf", width = 20, height = 12, units = "cm")
```


## Exercise

1. **Generate the following plot.** 

You are required to:

- Specify the dataset as `metabric`
- x-axis plots `Integrative_cluster` column and y-axis plots `ESR1` column.
- Use the suitable geom function
- Use `labs(x = ?, y = ?)` method and replace `?` with correct x and y labels.   

```{r}
#| echo: false
# plot the ESR1 expression for each integrative cluster
ggplot(data = metabric, aes(x = Integrative_cluster, y = ESR1, fill = Integrative_cluster)) +
  geom_boxplot() +
  labs(x = "Integrative cluster", y = "ESR1 expression")
```

2. **The default theme has the characteristic grey background which isn't particularly suitable for printing on paper. We can change to one of a number of alternative themes available in the ggplot2 package. Add a theme to create the following plot.**

```{r}
#| echo: false
ggplot(data = metabric, aes(x = Integrative_cluster, y = ESR1, fill = Integrative_cluster)) +
  geom_boxplot() +
  labs(x = "Integrative cluster", y = "ESR1 expression") + 
  theme_bw()
```

---

^*These content were adapted from the [Introduction to R: exploring the tidyverse](https://sanduni-p.github.io/IntroR/) course materials.*^

------------------------------------------------------------------------
